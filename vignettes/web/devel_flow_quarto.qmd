---
title: "Devel: Model evaluation flowchart"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Devel: Model evaluation flowchart}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Mapping from component inputs and latent states to component effects

```{mermaid}
%%| fig-width: 8
flowchart TD

subgraph "main, group, replicate"
  input(input)
  mapper(mapper)
end
weights("weights")
input_comb("combined inputs:<br/>list(mapper = list(main, group, replicate),<br/>scale = weights)")
multi_mapper("mapper_multi<br/>list(main, group, replicate)")
scale_mapper(mapper_scale)
lin("mapper_linearised<br/>(offset, jacobian, state0)")
effect(effect)

ibm_is_lin{ibm_is_linear}
state(state)
ibm_lin[ibm_linear]
ibm_eval[ibm_eval]

%% edge definitions with the node IDs
input --> input_comb
weights --> input_comb
input_comb --> ibm_eval
input_comb --> ibm_lin
scale_mapper --> ibm_is_lin
ibm_is_lin -->|Yes| ibm_lin
ibm_is_lin -->|No| ibm_eval
ibm_lin --> lin
lin --> ibm_eval
state --> ibm_eval
state-->ibm_lin
mapper --> multi_mapper --> scale_mapper
ibm_eval --> effect
```

## Linearising a mapping

```{mermaid}
flowchart TD

mapper(mapper)
input(input)
state(state)
off("offset<br/>")
jac("jacobian<br/>")
lin("mapper_linearised<br/>(offset, jacobian, state0)")

ibm_A[ibm_amatrix]
ibm_lin[ibm_linear]
ibm_jac[ibm_jacobian]
ibm_off[ibm_offset]

%% edge definitions with the node IDs
mapper-->ibm_lin
input-->ibm_lin
state-->ibm_lin
ibm_lin --> ibm_off
ibm_lin --> ibm_jac
ibm_off --> off
ibm_jac --> jac
ibm_jac --- ibm_A
ibm_lin --> lin
off-->lin
jac-->lin
state-->lin
```

## Component input evaluation

For each `<label>` of `main`, `group`, `replicate`, and `weights`, the given expression `expr`
is evaluated in the data context, producing the `input` to the component `mapper`.
For spatial covariate inputs, the corresponding `<label>_layer` expression is also evaluated.

Red nodes indicate deprecated behaviour retained for backwards compatibility.

```{mermaid}
%%| fig-width: 8
flowchart TD
  expr(expr)
  data(data)
  _envir(.envir)
  input("`label`_input")
  input0(input = NULL)
  input1(input = 1)
  style input1 color:#f00

  eval[eval]
  eval_function["value=fun(.data.)"]
  eval_formula["model.Matrix"]
  eval_spatial["eval_spatial"]
  eval_coordinates["SpatialPoints(value, crs)"]
  style eval_coordinates color:#f00
  eval_crs["crs=fm_sp_get_crs(.data.)"]

  error{error}
  null_on_fail{"null_on_fail?"}
  is_function{"Is it a<br/>function?"}
  is_coordinates_fun{"Is expr=coordinates?"}
  is_formula{"Is it a<br/>formula?"}
  is_spatial{"Is it a<br/>spatial covariate?"}

  expr --> eval --> error
  data --> eval
  _envir --> eval
  error -->|Yes| null_on_fail
  error -->|No| is_function
  null_on_fail -->|TRUE| input0
%%  {rank=same; error; null_on_fail; input0}
  null_on_fail -->|FALSE| input1
  input0 --> input
  input1 --> input
  
  is_function -->|Yes| eval_function
  is_function -->|No| is_formula
  eval_function --> is_coordinates_fun
%%  {rank=same; is_function; eval_function}

  is_coordinates_fun -->|Yes| eval_coordinates
  is_coordinates_fun -->|No| input
  eval_coordinates --> input
  eval_crs --> eval_coordinates
%%  {rank=same; is_coordinates_fun; eval_coordinates}

  is_formula -->|Yes| eval_formula
  is_formula -->|No| is_spatial
  eval_formula --> input
%%  {rank=same; is_formula; eval_formula}

  is_spatial -->|Yes| eval_spatial
  is_spatial -->|No| input
  eval_spatial --> input
%%  {rank=same; is_spatial; eval_spatial}

%% spatial covariate layer input
  layer_expr("`label`_expr")
  layer("`label`_layer")
  layer_eval["eval"]
  is_spatial -->|Yes| layer_eval
  data --> layer_eval
  _envir --> layer_eval
  layer_expr --> layer_eval --> layer --> eval_spatial

```
```{r eval=TRUE,echo=FALSE}
DiagrammeR::grViz("digraph {
  graph [layout = dot, rankdir = TB]

  node [shape = oval]
  expr
  data
  _envir [label = '.envir']
  input
  input0 [label = 'input = NULL']
  input1 [label = 'input = 1', color = red]

  node [shape = rectangle]
  eval
  eval_function [label = 'value=fun(.data.)']
  eval_formula [label = 'model.Matrix']
  eval_spatial [label = 'eval_spatial']
  eval_coordinates [label = 'SpatialPoints(value,crs)', color = red]
  eval_crs [label = 'crs=fm_sp_get_crs(.data.)']

  node [shape = diamond]
  error
  null_on_fail [label = 'Is null_on_fail\n TRUE?']
  is_function [label = 'Is it a\nfunction?']
  is_coordinates_fun [label = 'Is expr=coordinates?']
  is_formula [label = 'Is it a\nformula?']
  is_spatial [label = 'Is it a\nspatial covariate?']

  {expr data _envir} -> eval -> error
  error -> null_on_fail [label = 'Yes']
  error -> is_function [label = 'No']
  null_on_fail -> input0 [label = 'Yes']
  {rank=same; error; null_on_fail; input0}
  null_on_fail -> input1 [label = 'No']
  {input0 input1} -> input
  
  is_function -> eval_function [label = 'Yes']
  is_function -> is_formula [label = 'No']
  eval_function -> is_coordinates_fun
  {rank=same; is_function; eval_function}

  is_coordinates_fun -> eval_coordinates [label = 'Yes']
  is_coordinates_fun -> input [label = 'No']
  eval_coordinates -> input
  eval_crs -> eval_coordinates
  {rank=same; is_coordinates_fun; eval_coordinates}

  is_formula -> eval_formula [label = 'Yes']
  is_formula -> is_spatial [label = 'No']
  eval_formula -> input
  {rank=same; is_formula; eval_formula}

  is_spatial -> eval_spatial [label = 'Yes']
  is_spatial -> input [label = 'No']
  eval_spatial -> input
  {rank=same; is_spatial; eval_spatial}
  }",
  width = 600,
  height = 600)
```
