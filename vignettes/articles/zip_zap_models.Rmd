---
title: "Devel: ZIP and ZAP models"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Devel: ZIP and ZAP models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
header-includes:
  - \newcommand{\bm}[1]{\boldsymbol{#1}}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = TRUE
)
```

(Vignette under construction!)

```{r setup, eval=TRUE, echo=TRUE, include=TRUE, message=FALSE}
library(dplyr)
library(ggplot2)
library(inlabru)
library(terra)
library(sf)
library(RColorBrewer)
library(magrittr)
library(patchwork)

# We want to obtain CPO data from the estimations
bru_options_set(control.compute = list(cpo = TRUE))
```

# Count model

In addition to point process models, `inlabru` can handle models with positive integer response, e.g. abundance models where species counts are recorded in every observed location. Count models can be seen as coarse aggregations of point process models.

The following example uses `gorillas` dataset. In order to obtain the counts data we rasterize the species count to the same granularity as the spatial covariates available for the `gorilla` data, and then aggregate the pixels to cover 25 times bigger area (5x5 pixels in original covariate raster dimensions). Finally, we mask the regions outside of study area.

```{r fig-count-raster, fig.cap="Counts of gorilla nests", fig.width=7, fig.height=5,out.width="80%", fig.align='center'}
gorillas_sf <- inlabru::gorillas_sf
nests <- gorillas_sf$nests
mesh <- gorillas_sf$mesh
boundary <- gorillas_sf$boundary
gcov <- gorillas_sf_gcov()
counts_rstr <- terra::rasterize(vect(nests), gcov, fun = sum, background = 0) %>%
  terra::aggregate(fact = 4, fun = sum) %>%
  mask(vect(boundary))
plot(counts_rstr)
counts_rstr <- counts_rstr %>%
  cellSize(unit = "km") %>%
  c(counts_rstr)
```

Now we need to extract the coordinates for these pixels. The plot below shows pixel locations for all pixels with non-zero counts.

```{r}
counts_df <- crds(counts_rstr, df = TRUE, na.rm = TRUE) %>%
  bind_cols(values(counts_rstr, mat = TRUE, na.rm = TRUE)) %>%
  rename(count = sum) %>%
  mutate(present = count > 0) %>%
  st_as_sf(coords = c("x", "y"), crs = st_crs(nests))
```


> What is the probability of encountering 0,1,2... nests per study site?

We create a mesh over the study sites and define a prior for it.

```{r fig-count-mesh, fig.cap="Mesh over the count locations", fig.width=7, fig.height=5,out.width="80%", fig.align='center'}
px_mesh <- fm_mesh_2d_inla(
  loc = st_intersection(st_as_sfc(counts_df), st_buffer(boundary, -0.05)),
  boundary = boundary,
  max.edge = c(0.5, 1),
  crs = st_crs(counts_df)
)

px_matern <- INLA::inla.spde2.pcmatern(px_mesh,
  prior.sigma = c(0.1, 0.01),
  prior.range = c(0.1, 0.01)
)

ggplot() +
  geom_fm(data = px_mesh) +
  # geom_sf(data=counts_df, aes(color=count), size=1, pch=4)+
  theme_minimal()
```

## Poisson GLM

Now we can define the Poisson model which relates the species count per observation plot to the spatial covariates, such as the vegetation type and elevation. In order to make the vegetation effect estimates identifiable relative to the intercept, we use `model = "factor_full"` and a sum-to-zero constraint. 
An alternative would be `model = "factor_contrast"` without constraint, but that would require a factor level reordering to avoid the most uncommon vegetation type being the reference level.

```{r fig-predict-poi, fig.width=7, fig.height=5, out.width="80%", fig.align='center'}
comps <- ~ vegetation(gcov$vegetation,
  model = "factor_full",
  hyper = list(prec = list(initial = log(1 / 1^2), fixed = TRUE)),
  constr = TRUE
) +
  elevation(gcov$elevation, model = "linear") +
  field(geometry, model = px_matern) + Intercept(1)

fit_poi <- bru(
  comps,
  like(
    family = "poisson", data = counts_df,
    formula = count ~ vegetation + elevation + field + Intercept,
    E = area
  )
)
summary(fit_poi)


lambda_poi <- predict(
  fit_poi, counts_df,
  ~ exp(vegetation + elevation + field + Intercept)
)

ggplot() +
  geom_fm(data = px_mesh) +
  gg(lambda_poi, aes(fill = mean), geom = "tile") +
  geom_sf(data = nests, color = "firebrick", size = 1, pch = 4, alpha = 0.2) +
  ggtitle("Nest intensity per 1.2 ha")
```

## True zeroes and false zeroes

The Poisson GLM model may produce zeros in some locations. These are called "true zeroes", because they are explained by the model and the covariates. The "false zeroes" do not comply with the covariates. They can appear because of the imperfection in sampling (wrong time or place), observer errors, non-suitable environment characteristics, etc. 

The number of zeros in our data is large and our model may not be able to accommodate for them. We should pick a model which can handle "inflated" number of zeros, i.e. in excess of what is implied by a regular Poisson model. For that we pick a "zero-inflated Poisson model", or simply, ZIP.

## ZIP model

The [Type 1 Zero-inflated Poisson model](https://inla.r-inla-download.org/r-inla.org/doc/likelihood/zeroinflated.pdf) is given by

$$
\text{Prob}(y\vert\dots)=p\times 1_{y=0}+(1-p)\times \text{Poisson}(y)
$$

where $p=\text{logit}^{-1}(\theta)$

```{r fig-pred-zip, fig.cap="Predictions from zero-inflated model",fig.width=7, fig.height=5, out.width="80%", fig.align='center'}
fit_zip <- bru(
  comps,
  like(
    family = "zeroinflatedpoisson1", data = counts_df,
    formula = count ~ vegetation + elevation + field + Intercept,
    E = area
  )
)

summary(fit_zip)

lambda_zip <- predict(
  fit_zip, counts_df,
  ~ (1 - zero_probability_parameter_for_zero_inflated_poisson_1) *
    exp(vegetation + elevation + field + Intercept)
)

ggplot() +
  geom_fm(data = px_mesh) +
  gg(lambda_zip, aes(fill = median), geom = "tile") +
  geom_sf(data = nests, color = "firebrick", size = 1, pch = 4, alpha = 0.2) +
  ggtitle("Nest intensity per 1.2 ha")
```

We will compare the performance of the models in the diagnostic section below.
<!-- This model is much better at differentiating between the sites and produces sensible predictions. [Note: this may not be the case; need to sort out the factor ordering and priors; check the diagnostic section below as well.] -->

## ZAP model

Judging by the distribution of nests in relation to the [spatial covariates](2d_lgcp_covars.Rmd), gorillas do not like to set their nests in certain vegetation. The type of vegetation may not influence the density of the nests, but it definitely drives the presence/absence. In this case the `vegetation` covariate should be included in the binomial part of the model, but not the Poisson part. 

Whenever the process that drives presence/absence is substantially different from the process that drives the abundance it is wise to switch to the Zero-Adjusted Poisson (ZAP) model, which consists of binomial and the truncated Poisson parts.

We switch to `zeroinflatedpoisson0` which has the [following likelihood](https://inla.r-inla-download.org/r-inla.org/doc/likelihood/zeroinflated.pdf)

$$
\text{Prob}(y\vert\dots)=p\times 1_{y=0}+(1-p)\times \text{Poisson}(y\vert y>0)
$$

where $p=\text{logit}^{-1}(\theta)$.  

Here ZIP distribution only governs the positive counts and the absences will be handled by a separate binomial model which can have its own covariates. Note, that we exclude the observations with absent nests from the ZIP part of the model by subsetting the data to include only observations where `present` is `TRUE`.

```{r fig-pred-zap, fig.cap="Predictions from zero-adjusted model",fig.width=7, fig.height=5, out.width="80%", fig.align='center'}
comps <- ~ vegetation(gcov$vegetation,
  model = "factor_full",
  hyper = list(prec = list(initial = log(1 / 1^2), fixed = TRUE)),
  constr = TRUE
) +
  elevation(gcov$elevation, model = "linear") +
  field(geometry, model = px_matern) + Intercept_present(1) + Intercept_count(1) +
  elevation_present(gcov$elevation, model = "linear") +
  field_present(geometry, copy = "field")

fit_zap <- bru(
  comps,
  like(
    family = "binomial",
    data = counts_df,
    formula = present ~ vegetation + elevation_present + field_present + Intercept_present
  ),
  like(
    family = "zeroinflatedpoisson0",
    data = counts_df[counts_df$present, ],
    formula = count ~ elevation + field + Intercept_count,
    E = area,
    control.family = list(hyper = list(theta = list(initial = -20, fixed = TRUE)))
  )
)
summary(fit_zap)

# Predict intensity on the original raster locations
lambda_zap <- predict(
  fit_zap, counts_df,
  ~ plogis(vegetation + elevation_present + field_present + Intercept_present, lower.tail = FALSE) *
    exp(elevation + field + Intercept_count)
)

ggplot() +
  geom_fm(data = px_mesh) +
  gg(lambda_zap, aes(fill = median), geom = "tile") +
  geom_sf(data = nests, color = "firebrick", size = 1, pch = 4, alpha = 0.2) +
  ggtitle("Nest intensity per 1.2 ha")
```

In order to make sure that Poisson distribution will be properly truncated, we included the `control.family` argument with the parameter `theta` (which gets translated into the probability $p$) is fixed to a large negative value, such that when transformed by $\text{logit}^{-1}(\theta)=p$ it would end up close to zero.

## Model comparison

The count prediction variance can be obtained from the predictions of the intensity $\lambda_i$ for each grid box. With $a_i$ denoting the respective grid box areas, the counts conditionally on the predictor $\eta_i$ are $(X_i\vert \eta_i) \sim \text{Poisson}(a_i\lambda_i)$.

$$
\begin{aligned}
V(X_i) &= E(V(X_i|\eta_i)) + V(E(X_i|\eta_i)) \\
&= E(a_i\lambda_i) + V(a_i\lambda_i) \\
&= a_i m_i + a_i^2s_i^2,
\end{aligned}
$$
where $m_i=E(\lambda_i|\text{data})$ and $s_i^2=V(\lambda_i|\text{data})$ are the
conditional mean and variance for $\lambda_i$.


```{r, out.width="100%", fig.width=10, fig.height=5, fig.align='center'}
lambda_poi$pred_var <-
  (lambda_poi$mean + lambda_poi$sd^2 * counts_df$area) * counts_df$area
lambda_zip$pred_var <-
  (lambda_zip$mean + lambda_zip$sd^2 * counts_df$area) * counts_df$area
lambda_zap$pred_var <-
  (lambda_zap$mean + lambda_zap$sd^2 * counts_df$area) * counts_df$area

zap_pit <- rep(NA_real_, nrow(counts_df))
zap_pit[counts_df$count > 0] <- fit_zap$cpo$pit[-seq_len(nrow(counts_df))]

df <- data.frame(
  count = rep(counts_df$count, times = 3),
  expectation = c(
    lambda_poi$mean * counts_df$area,
    lambda_zip$mean * counts_df$area,
    lambda_zap$mean * counts_df$area
  ),
  pred_var = c(
    (lambda_poi$mean + lambda_poi$sd^2 * counts_df$area) * counts_df$area,
    (lambda_zip$mean + lambda_zip$sd^2 * counts_df$area) * counts_df$area,
    (lambda_zap$mean + lambda_zap$sd^2 * counts_df$area) * counts_df$area
  ),
  median = c(
    lambda_poi$median * counts_df$area,
    lambda_zip$median * counts_df$area,
    lambda_zap$median * counts_df$area
  ),
  pit = c(
    fit_poi$cpo$pit * c(NA_real_, 1)[1 + (counts_df$count > 0)],
    fit_zip$cpo$pit * c(NA_real_, 1)[1 + (counts_df$count > 0)],
    zap_pit
  ),
  model = rep(c("poi", "zip", "zap"), each = nrow(counts_df))
)

p1 <- ggplot(df) +
  geom_point(aes(median, count - median, color = model)) +
  ggtitle("Residuals")

p2 <- ggplot(df) +
  stat_ecdf(aes(pit, color = model), na.rm = TRUE) +
  scale_x_continuous(expand = c(0, 0)) +
  ggtitle("PIT")

patchwork::wrap_plots(p1, p2, nrow = 1)

df %>%
  group_by(model) %>%
  summarise(mae = mean(abs(count - median)))
```

Dawid-Sebastiani scores

```{r, out.width="100%", fig.width=15, fig.height=5, fig.align='center'}
lambda_poi$DS <- with(lambda_poi, (counts_df$count - mean)^2 / pred_var + log(pred_var))
lambda_zip$DS <- with(lambda_zip, (counts_df$count - mean)^2 / pred_var + log(pred_var))
lambda_zap$DS <- with(lambda_zap, (counts_df$count - mean)^2 / pred_var + log(pred_var))

# Mean Dawid-Sebastiani scores
c(mean(lambda_poi$DS), mean(lambda_zip$DS), mean(lambda_zap$DS)) %>%
  set_names(c("Poisson", "ZIP", "ZAP"))

p1 <- ggplot() +
  geom_fm(data = px_mesh) +
  gg(lambda_poi, aes(fill = DS), geom = "tile") +
  geom_sf(data = nests, color = "firebrick", size = 1, pch = 4, alpha = 0.2) +
  ggtitle("Poisson Dawid-Sebastiani scores") +
  guides(fill = guide_legend("score"))
p2 <- ggplot() +
  geom_fm(data = px_mesh) +
  gg(lambda_zip, aes(fill = DS - lambda_poi$DS), geom = "tile") +
  geom_sf(data = nests, color = "firebrick", size = 1, pch = 4, alpha = 0.2) +
  ggtitle("ZIP Dawid-Sebastiani score difference") +
  guides(fill = guide_legend("score"))
p3 <- ggplot() +
  geom_fm(data = px_mesh) +
  gg(lambda_zap, aes(fill = DS - lambda_poi$DS), geom = "tile") +
  geom_sf(data = nests, color = "firebrick", size = 1, pch = 4, alpha = 0.2) +
  ggtitle("ZAP Dawid-Sebastiani score difference") +
  guides(fill = guide_legend("score"))

patchwork::wrap_plots(p1, p2, p3, nrow = 1)
```
